#+Title: DB Doc

Document your database tables and fields, because you should, and this
makes it easy.

DBDoc enables you to describe your relational database tables and
their columns in a simple text file, which is easy and nice for
developers to edit and search in the repo. The docs are then viewable
in an SQL client (the main use case) as tooltips and elsewhere, are
greppable, and can be published as docs, which enables other
stakeholders (eg, Product people) to view DB documentation (in
Confluence or wherever).

It works by converting a very minimal ORG-valid and -prescribed syntax
(top-level bullets, single paragraphs, and definition lists) into
(long) [[https://www.postgresql.org/docs/current/sql-comment.html][SQL =COMMENT ON= statements]], which can be run automatically on
your database (via migration or sourced or however you like).

#+html: <p align="center"><img src="film-hover.png" /></p>
#+html: <p align="center"><img src="film-table2.png" /></p>
#+html: <p align="center"><img src="postico.png" /></p>

** Example dbdoc.org file

The following shows an example dbdoc.org file describing a movie store
rental database and a few of its tables: =film= (containing =title=
and =description= columns), =movie= (a deprecated table with no
columns documented), and =actor=. Notice: the hyphens instead of
underscores, newlines before definitions, other indentation.

An example translation then is from:

#+begin_src org
#+Title: Pagila Movie Store Rental Database

* FILM

A film, aka movie, is released initially in theaters, and then
available to movie /stores/, at which point they become available to
the DB.

- title ::
  The full name of the film, including things like sub-title and part
  in a series; does not include language

- description ::
  A brief synopsis (catchy prose) about the plot

* MOVIE

DEPRECATED: replaced by =film=

* ACTOR

An actor is very simple and non-comprehensive table to record the main
headlining /stars/ of the film. All fields are obvious. Note that
there may be duplicate actors that use slightly different names on occasion.
#+end_src

to an SQL migration file containing:

#+begin_src sql
COMMENT ON TABLE film IS 'A film, aka movie …';
COMMENT ON COLUMN film.title IS 'The full name …';
…
COMMENT ON TABLE movie IS 'DEPRECATED: replaced …';
…
#+end_src

Compared to the ORG version, that SQL is pretty ugly – editing
(quoting, line-length/newlines, indentation, formatting) becomes quite
difficult. That’s why this tiny tool exists.

There is a testable =docs/dbdoc.org= example (and its generated SQL
migration file =resources/migrations/20210804162056-dbdoc.up.sql=) in
this repo that was written to minimally describe the [[https://github.com/devrimgunduz/pagila][pagila toy
database]]. Just run =dbdoc.clj= in the root of this repo to try it out!

** Installation

- Install [[https://github.com/babashka/babashka#installation][Babashka]].
- Clone this repo and put its root on your =PATH=.

Now you're ready to run =dbdoc.clj= from anywhere, and that's all
there is to it! Not even any CLI options. :)

** Documentation Process

*** One time only

- Create a single living .org file in your repo, eg, =docs/dbdoc.org=
  for growing docs for your tables.

- Assuming you haven't already somehow written a =COMMENT= for your
  DB, turn a SME analyst type or long-time developer in your company
  loose to write up a bunch of notes in the org file. Then edit a bit
  to ensure it's valid ORG that dbdoc can handle..

- Set up env vars to change default file locations (optional, not well
  tested):

  #+begin_src shell
  export DBDOC_ORG=docs/dbdoc.org
  export DBDOC_SQL=resouces/migrations/<timestamp>-dbdoc.up.sql
  export DBDOC_HTML=docs/dbdoc.html
  #+end_src

*** Continually (this is the only real process)

1. Keep describing as many tables and columns as you see fit in your
   =docs/dbdoc.org= file. Every time a developer changes or adds a
   field or table, they also put a sentence or two describing its
   purpose in the org file.

2.  Run =dbdoc.clj= to generate a time-stamped file like
   =resources/migrations/20201027000000-dbdoc.up.sql=. IMPORTANT!!
   Don't forget this step! (You don't need all the developers on the
   teams do this, so long as /someone/ does the generation/migrating
   once in a while.)

3. Commit both the org and migration files.

*** Optional

- Generate HTML (from command line [[https://pandoc.org/][with Pandoc]] or [[https://stackoverflow.com/a/22091045/326516][Emacs]]) and publish
  the new version to some site your company views (optional, see
  =org2connflu.zsh= script).

- If your migrations aren't automatic as part of your CI, run your
  migration (or just load the new SQL file if you don't do
  migrations).

** Table Documentation Best Practices

- Don’t need to be comprehensive and document every field when names
  make them obvious
- Add an example datum for a column
- Used-by references: other tables (probably not FKs) and code areas
- Gotchas/quirks
- Add characteristic tags: deprecated/defunct, xl, hot, new, static,
  performance, donttouch, dragons

** Showing Comments in Clients

- psql: =\d+=
- mysql: =show full comments from <table_name>=
- [[https://dataedo.com/kb/tools/dbeaver/how-to-view-and-edit-table-and-column-comments][dbeaver]] (HIGHLY RECOMMENDED!! the docs pop up everywhere)
- [[https://eggerapps.at/postico/][postico]] (see the _Structure_ tab, as shown is screenshot)
- [[https://postgrest.org/en/v7.0.0/api.html#openapi-support][postgrest/swagger]]
- [[https://dataedo.com/kb/tools/pgadmin/how-to-view-and-edit-table-and-column-comments][pgadmin]]
- [[https://dataedo.com/kb/tools/datagrip/how-to-view-and-edit-table-and-column-comments][datagrip]]

** Read on if you want more details...

*** Transformations

The parser is really limited and rigid and wants to see a _table_
description paragraph for every table you wish to document. So, if you
want to document some column in a table, you must also provide at
least a tidbit sentence for the table too. It's not a good parser so
just be careful. Alignment/indentation is important too, so follow the
example format precisely – this is a tiny subset of actual org.

Org uses underscores for italic, and it’s tedious enough to have to
wrap every DB entity in equals (+=+) in org to escape them, so they
should instead be documented with hyphens (=-=) (though this isn’t
required). IOW, all ORG hyphenated variables (eg, =my-var-name=)
become underscores in SQL (=my_var_name=). So prefer to use
=my-var-name= in the ORG description.

It you use “straight” apostrophes ('), they’ll be converted to
curlies so as not to need SQL string escaping (and be prettier).

*** Git Diffs

The dbdoc script looks for an old migration file called
=<timestamp>-dbdoc.up.sql= and renames it (via =git-move=) to a
present timestamp. This enables Git to see the the new migration as
simply a change from the last run, and so you can easily see the
before/after diff. This also saves on a clutter of generating a bunch
of extra migrations.

*** Round-Tripping (coming soon maybe)

If you already have comments on your tables, you can pull them into
your ORG doc to still get the benefits of shared editing/viewing. So
if some of your team happens to add comments inside a client on your
production DB, round-tripping enables never losing data, and keeping
your =dbcoc.org= as the SPOT. (This is maybe coming soon; probably
not.)

*** Seeding an ORG doc file for first-time use

You can create a listing of all existing public tables as a starter
ORG file: see =schema2org.zsh=. Once created, you can just start
documenting! This is probably totally buggy; it's a tiny sed script
working off a pg-dump.

This may be improved to populate with existing comment descriptions
to enable “round-tripping”.

*** FAQs

*Why use org instead of the more popular/common markdown?*

ORG has definition lists which work great for column docs. For the
limited syntax that is dbdoc, org and md are effectively the same
(just use =*= for heading instead of =#=).

*Do I need Emacs to work with Org files?*

No! Emacs is not required to for any part of dbdoc. Most common
editors have some proper way to work with Org. Even if yours doesn't,
just edit in plain text mode.

*How far should I go with documenting my tables?*

Not super far. See recommendations above. I like to limit column docs
to not more than a few sentences. A table doc can be a legthy
paragraph (only one!). Your source code docstrings are probably a
better place to get into the nitty gritty.

*Why not just write the doc strings in SQL?*

Then your editor would think you’re in SQL mode and wouldn’t do things
like spell-checking or nice formatting. Plus, using ORG gives you a
publishable HTML version of your docs.

*Does this work for all databases?*

No, not quite. It's been tested with PostgreSQL, but should work with
MySQL too. [[https://stackoverflow.com/questions/7426205/sqlite-adding-comments-to-tables-and-columns][I don't think SQLite supports =COMMENT=.]] Don't see any
reason it wouldn't work with several other relational SQL DBs though,
like SQL Server and Oracle which also support the syntax.

*How do I get this into Confluence without API access?*

Your Confluence setup might only support creating a page from markdown
(not org or html). So you can use pandoc to convert from org to md
with: =pandoc -s docs/dbdoc.org -o temp.md= and then paste it into
Confluence from its "plus" menu while editing a page:
/Markup > Markdown > Paste > Insert/

*Why can't I use just my SQL client to add descriptive comment?*

Because it seems you shouldn't. Which DB are you wanting to modify?
Are you connecting your client to a production DB and making edits to
prod data? This doesn't make sense to me and I don't understand why
clients support =COMMENT= editing. Developers, QA, and others
probably all need different non-prod DBs to have up-to-date
documentation at their fingertips, and dbdoc enables putting that
documentation into every instance.

** Similar Tools Comparison

*** dbdocs (same name but plural!)

[[https://dbdocs.io/][dbdocs]] is decsribed as: "A free & simple tool to create web-based
database documentation using DSL code. Designed for developers.
Integrate seamlessly with your development workflow." As a full DDL
DSL, it is a much heavier commitment to incorporate. It also creates a
rich website for your tables, whereas DBDoc.org just creates a single
webpage that can be synced with Confluence or published wherever you
choose. dbdocs creates ERDs, but DBDoc.org lets clients like DBeaver
handle that for you.

*** Commercial Tools

There are many DB documentation tools in this realm. If you're
interested in much more sophisticated all-in-one type tools that may
work with other types of DBMSs, look into [[https://www.apexsql.com/sql-tools-doc.aspx][ApexSQL]], [[https://www.red-gate.com/products/sql-development/sql-doc/][Redgate]], and
[[https://dataedo.com/][Dataedo]].

** Future Enhancements

- Support =COMMENT ON DATABASE= as top-level paragraph (but ignore
  myriad other types). *Actually, this can't be done flexibly since it
  requires knowing the DB name.*
