#+Title: DB Doc

Document your database tables and fields, because you should, and this
makes it easy.

DBDoc enables you to describe your relational database tables and
their columns in a simple ORG text file, which is easy and nice for
developers to edit and search in the repo. The docs are then viewable
in an SQL client as tooltips and elsewhere (the main use case), and
can be published as docs, which enables other stakeholders (eg,
Product people) to view DB documentation.

It works by converting a very minimal ORG-valid and -prescribed syntax
(top-level bullets, single paragraphs, and definition lists) into
(long) [[https://www.postgresql.org/docs/current/sql-comment.html][SQL =COMMENT ON= statements]], which can be run automatically on
your database (via migration or sourced or however you like).

#+html: <p align="center"><img src="film-hover.png" /></p>
#+html: <p align="center"><img src="film-table.png" /></p>
#+html: <p align="center"><img src="postico.png" /></p>

** Example dbdoc.org file

The following shows an example dbdoc.org file describing a movie store
rental database and a few of its tables: =film= (containing =title=
and =description= columns), =movie= (a deprecated table with no
columns documented), and =actor=. Notice: the hyphens instead of
underscores, newlines before definitions, other indentation.

An example translation then is from:

#+begin_src org
#+Title: Pagila Movie Store Rental Database

* film

A film, aka movie, is released initially in theaters, and then
available to movie /stores/, at which point they become available to
the DB.

- title ::
  The full name of the film, including things like sub-title and part
  in a series; does not include language

- description ::
  A brief synopsis (catchy prose) about the plot

* movie

DEPRECATED: replaced by =film=

* actor

An actor is very simple and non-comprehensive table to record the main
headlining /stars/ of the film. All fields are obvious. Note that
there may be duplicate actors that use slightly different names on occasion.
#+end_src

to an SQL migration file containing:

#+begin_src sql
COMMENT ON TABLE film IS 'A film, aka movie …';
COMMENT ON COLUMN film.title IS 'The full name …';
…
COMMENT ON TABLE movie IS 'DEPRECATED: replaced …';
…
#+end_src

Commpared to the ORG version, that SQL is pretty ugly – quoting,
line-length, indentation become nearly impossible. That’s why this
tiny tool exists.

There is a testable =docs/dbdoc.org= example (and its generated SQL
migration file =resources/migrations/20210804162056-dbdoc.up.sql=) in
this repo that was written to minimally describe the [[https://github.com/devrimgunduz/pagila][pagila toy
database]]. Just run =dbdoc.clj= in the root of this repo to try it out!

** Installation

- Install [[https://github.com/babashka/babashka#installation][Babashka]].
- Clone this repo and put =dbdoc= on your =PATH=.

** Process

One time only, create a single living .org file in your repo, eg,
=docs/dbdoc.org= for growing docs for your tables.

Assuming you haven't already somehow written a =COMMENT= for your DB,
turn a SME analyst type or long-time developer in your company loose
to write up a bunch of notes in the org file. Then edit a bit to
ensure it's valid ORG that dbdoc can handle..

Set up env vars to control file locations (optional, not well tested):

#+begin_src shell
export DBDOC_ORG=docs
export DBDOC_SQL=resouces/migrations
export DBDOC_HTML=docs
#+end_src

Then, continually:

- Keep describing as many tables and columns as you see fit in your
  =docs/dbdoc.org= file.

- Run =dbdoc.clj= to generate a time-stamped file like
  =resources/migrations/20201027000000-dbdoc.up.sql=. IMPORTANT!!
  Don't forget this step! (You don't need all the developers on the
  teams do this, so long as /someone/ does the generation/migrating
  once in a while.)

- Commit both the org and migration files.

- Generate HTML (from command line [[https://pandoc.org/][with Pandoc]] or [[https://stackoverflow.com/a/22091045/326516][Emacs]]) and publish
  the new versions to some site your company views (optional).

- If your migrations aren't automatic as part of your CI, run your
  migration (or just load the new SQL file if you don't do
  migrations).

** Table Documentation Best Practices

- Don’t need to be comprehensive and document every field when names
  make them obvious
- Add an example datum for a column
- Used-by references: other tables (probably not FKs) and code areas
- Gotchas/quirks
- Add characteristic tags: deprecated/defunct, xl, hot, new, static,
  performance, donttouch, dragons

** Showing Comments in Clients

- psql: =\d+=
- mysql: =show full comments from <table_name>=
- [[https://dataedo.com/kb/tools/dbeaver/how-to-view-and-edit-table-and-column-comments][dbeaver]] (HIGHLY RECOMMENDED!! the docs pop up everywhere)
- [[https://eggerapps.at/postico/][postico]] (see the _Structure_ tab, as shown is screenshot)
- [[https://postgrest.org/en/v7.0.0/api.html#openapi-support][postgrest/swagger]]
- [[https://dataedo.com/kb/tools/pgadmin/how-to-view-and-edit-table-and-column-comments][pgadmin]]
- [[https://dataedo.com/kb/tools/datagrip/how-to-view-and-edit-table-and-column-comments][datagrip]]

** Read on if you want more details...

*** Transformations

The parser is really limited and rigid and wants to see a _table_
description paragraph for every table you wish to document. So, if you
want to document some column in a table, you must also provide at
least a tidbit sentence for the table too. It's not a good parser so
just be careful. Alignment/indentation is important too, so follow the
example format precisely – this is a tiny subset of actual org.

Org uses underscores for italic, and it’s tedious enough to have to
wrap every DB entity in equals (+=+) in org to escape them, so they
should instead be documented with hyphens (+-+) (though this isn’t
required). IOW, all ORG hyphenated variables (eg, =my-var-name=)
become underscores in SQL (=my_var_name=). So prefer to use
=my-var-name= in the ORG description.

It you use “straight” apostrophes (+'+), they’ll be converted to
curlies so as not to need SQL string escaping (and be prettier).

*** Git Diffs

The dbdoc script looks for an old migration file called
=<timestamp>-dbdoc.up.sql= and renames it (via =git-move=) to a
present timestamp. This enables Git to see the the new migration as
simply a change from the last run, and so you can easily see the
before/after diff. This also saves on a clutter of generating a bunch
of extra migrations.

*** Round-Tripping (coming soon maybe)

If you already have comments on your tables, you can pull them into
your ORG doc to still get the benefits of shared editing/viewing. So
if some of your team happens to add comments inside a client on your
production DB, round-tripping enables never losing data, and keeping
your =dbcoc.org= as the SPOT. (This is maybe coming soon; probably
not.)

*** Seeding an ORG doc file for first-time use

You can create a listing of all existing public tables as a starter
ORG file: see =schema2org.zsh=. Once created, you can just start
documenting! This is probably totally buggy; it's a tiny sed script
working off a pg-dump.

This may be improved to populate with existing comment descriptions
to enable “round-tripping”.

*** Q & A

*Why use org instead of the more popular/common markdown?*

ORG had definition lists. For the limited syntax that is dbdoc,
they’re effectively the same (just use +*+ for heading instead of
+#+).

*Do I need Emacs to work with Org files?*

No! Emacs is not required to for any part of dbdoc. Most common
editors have some proper way to work with Org. Even if yours doesn't,
just edit in plain text mode.

*How far should I go with documenting my tables?*

Not too far. See recommendations above.

*Why not just write the doc strings in SQL?*

Then your editor would think you’re in SQL mode and wouldn’t do things
like spell-checking or nice formatting. Plus, using ORG gives you a
publishable HTML version of your docs.

*Does this work for all databases?*

No, not quite. It's been tested with PostgreSQL, but should work with
MySQL too. [[https://stackoverflow.com/questions/7426205/sqlite-adding-comments-to-tables-and-columns][I don't think SQLite supports =COMMENT=.]] Don't see any
reason it wouldn't work with several other relational SQL DBs though,
like SQL Server and Oracle which also support the syntax.

** TODO

- Support =COMMENT ON DATABASE= as top-level paragraph (but ignore
  myriad other types)
